# CAP
## Consistency
- 一致性
- 写操作后的读操作可以读取到最新的数据状态
- 数据分布在多个节点时，从任意节点读取到的数据都是最新的状态
- 存在数据同步的过程，写操作的响应会有延迟
- 为了保证数据的一致性，会暂时锁住资源，等数据同步完成释放资源
- 如果请求的节点数据同步失败了，则返回错误信息，一定不能返回旧数据
## Availability
- 可用性
- 所有请求都有相应
- 不能响应超时
- 不能响应错误
## Partition tolerance
- 分区容错性
- 必须保证
# 分布式锁
- 解决分布式集群下数据一致性问题
## zk分布式锁
- 基于CP实现，强一致性
- 通过ZAB(Zookeeper Atomic Broadcast)协议实现
- 基于临时顺序节点和Watcher（事件监听器）实现
- 获取锁【持久节点/locks，获取锁就是在locks下创建临时顺序节点】
> 客户端1创建/locks/lock1，判断lock1是否是locks下的最小子节点
> 若lock1是最小子节点，获取锁成功
> 若lock1不是最小子节点，不会不停循环尝试获取锁，而是在前一个子节点上注册一个事件监听器，前一个子节点释放锁后通过监听器通知客户端1，客户端1获取锁成功
![](https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/distributed-lock-zookeeper.png)
- 释放锁
> 成功获取锁的客户端执行完业务后，删除对应的子节点，事件监听器监听子节点删除事件
> 成功获取锁的客户端出现故障，对应的子节点是临时顺序节点会自动删除，避免锁无法释放
## redis分布式锁
- 基于AP实现，性能高
# 分布式事务
## 2pc
- 准备阶段prepare
> TC向所有参与者发送prepare请求，询问是否可以提交事务，参与者执行事务操作但不提交，向TC反馈prepare结果
- 提交阶段commit
> 若所有参与者都反馈可以提交，则TC向所有参与者发送commit指令，参与者接收到commit指令后，提交事务，向TC反馈commit结果
> 若有参与者反馈不能提交，则TC向所有参与者发送abort指令，回滚事务
## 3pc
- canCommit阶段
> TC询问所有参与者是否可以提交事务，参与者反馈是否准备好进行preCommit
- preCommit阶段
> 若所有参与者都同意preCommit，TC发送preCommit指令，参与者接收指令，执行事务操作但不提交，记录日志，向TC反馈preCommit结果
- doCommit阶段
> TC根据参与者的反馈决定是否发送commit或abort指令，参与者根据TC的最终指令，执行commit或abort操作
## Seata【协调本地事务来实现全局事务的一致性，不是实现一个全局的事务管理器】
- TC：事务协调者 TM：事务管理器 RM：资源管理器
- 事务开始：TM向TC请求开始一个全局事务，TC生成一个全局唯一标识XID返回给TM
- 分支注册：RM向TC注册分支事务，并关联XID
- 本地操作：RM执行本地事务操作
- 分支完成：RM向TC报告分支事务的状态
- 全局提交或回滚：TM决定全局提交或回滚，并通知TC，TC根据TM的决策，向RM发送提交或回滚指令
## 分布式事务中，InnoDB存储引擎的事务隔离级别必须设置为串行化SERIALIZABLE