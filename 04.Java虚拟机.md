# JVM组成
## 子系统
### Class Loader
- 类加载器：根据全限定类名（如java.lang.Object）装载class文件到运行时数据区的方法区
### Execution Engine
- 执行引擎：执行classes中的指令
## 组件
### Runtime data area
- 运行时数据区：JVM内存
### Native interface
- 本地接口：与Native libraries（本地方法库）交互
# 
![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171729fc868d44b7~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)
## 流程
- 编译器将java代码转换成class字节码
- 类加载器将字节码加载到内存，放到运行时数据区的方法区
- class字节码只是JVM的一套指令集规范，无法被底层系统执行
- 执行引擎将class字节码翻译成底层系统指令，交由CPU执行
- 上述过程需要调用其他语言的本地库接口实现对应功能
# 运行时数据区
## 程序计数器-PC
- 线程私有
- 保存当前线程正在执行的字节码指令地址
- 唯一不会报OOM Exception异常的区域
## 虚拟机栈
- 线程私有
- 基本单位：栈桢
### 栈桢
- 局部变量表：临时变量、对象引用、return后要执行的字节码指令地址
- 操作数栈：用来操作
- 动态链接：链接其他方法，存储链接地址
- 方法出口：return或抛出异常
## 本地方法栈
- 线程私有
- 和虚拟机栈类似，一个是java方法，一个是native修饰的本地方法
## 方法区
- 线程共享
### jdk1.7之前
- 类型信息、字段、方法、运行时常量池、即时编译JIT代码、字符串常量池、静态变量保存在永久代
### jdk1.7
- 又叫永久代（仅对hotspot而言）
- 使用虚拟机设置的内存
- 设置方式：-XX:PermSize设置初始分配空间，-XX:MaxPermSize设置最大分配空间
- 类型信息、字段、方法、运行时常量池、即时编译JIT代码保存在永久代，字符串常量池、静态变量保存在堆
### jdk1.8
- 又叫元空间（实现方式）
- 使用本地内存
- 设置方式：-XX:MetaspaceSize设置初始分配空间，-XX:MaxMetaspaceSize设置最大分配空间
- 类型信息、字段、方法、运行时常量池、即时编译JIT代码保存在本地内存的元空间，字符串常量池、静态变量保存在堆
## 堆
- 线程共享
- 存放对象实例、数组
- GC主要区域
# GC
## 定义
- 监控对象使用情况，自动回收对象的内存空间
## 对象引用类型
### 强引用
- 正常创建的对象引用
- GC不会回收
### 软引用-SoftReference
- 继承SoftReference类
- 内存不足GC才回收
### 弱引用-WeakReference
- 继承WeakReference类
- 每次GC都回收
### 虚引用-PhantomReference
- 继承PhantomReference类
- 跟踪对象被GC回收的活动
## 如何判断对象是否可回收
### 引用计数法
- 为每个对象创建一个引用计数，被引用时+1，引用被释放时-1，引用计数为0可以被回收
- 存在循环引用问题
### 可达性分析
- 从GC Roots开始向下探索，搜索走过的路径成为引用链，对象到GC Roots没有任何引用链时，可以被回收
- 虚拟机栈中局部变量表中引用的对象
- 本地方法栈中本地方法引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
## GC算法
### 标记-清除
- 标记无用对象
- 清除回收
- 产生内存碎片
### 复制
- 内存划分为相等的两份
- 每次只使用其中一份
- 遍历使用的区域，将存活的对象复制到另一份
- 清除回收
- 解决内存碎片问题，可用内存减半，对象存活率高时频繁复制
### 标记-整理
- 标记无用对象
- 让所有存活的对象移动到一端
- 清除回收
- 解决内存碎片问题，需要移动对象，降低效率
## 老年代、新生代、永久代
### 老年代(占2/3)
- 存活时间长的对象
- 需要存储空间大的对象
- 标记-清除或标记-整理
### 新生代(占1/3)
- 新创建的对象
- 每次GC，只有少量的对象存活
- 标记-复制
### 永久代
- JVM的方法区
## 新生代的区域划分
- Eden(80%)
- From Survivor(10%)
- To Survivor(10%)
- 没有Survivor，Eden区存活的对象都要放到老年代，老年代很快被占满，触发Major GC，时间消耗长
- 对象存放在Eden
- 第一次GC，Eden中存活的对象放进Survivor1，回收Eden
- 第二次GC，Eden和Survivor1中存活的对象放进Survivor2，回收Eden和Survivor1
- 第三次GC，Eden和Survivor2中存活的对象放进Survivor1，回收Eden和Survivor2
- ...
- 每次放进Survivor时，对象的年龄+1，默认年龄达到15，放进老年代
## 垃圾回收器
### 新生代
- Serial
- ParNew
- Parallel Scavenge
### 老年代
- Serial Old
- Parallel Old
- CMS(Concurrent Mark Sweep)：采用标记-清除，无法处理浮动垃圾，会产生空间碎片
### 整堆
- G1：整体看标记-整理，局部看标记-复制，JDK9及以后的默认垃圾回收器
# 内存分配
- 对象在堆上分配
- 对象在Eden区
- 大对象在老年代
# 类加载
## 流程
### 加载
- 将class字节码文件读到内存
- 在堆中生成一个类的Class对象
- Class对象封装了在方法区中的数据结构
- 向用户提供了访问方法区数据结构的接口-Java反射的接口
### 验证
- 确保class文件是否符合JVM规范
### 准备
- 为类静态变量分配内存并设置变量的默认值
### 解析
- 常量池的符号引用替换成字节引用
### 初始化
- 执行类构造器方法（设置类静态变量的初始值、静态代码块的执行）
- 初始化类及其父类
## 类加载器
### BootStrap ClassLoader
- 启动类加载器
- 加载/lib目录下的类库
### Extension ClassLoader
- 扩展类加载器
- 加载/lib/ext目录下的类库
### Application ClassLoader
- 应用程序类加载器
- 加载用户类路径指定的类库
### 继承ClassLoader抽象类的自定义类加载器
- parent：父类加载器
- defineClass：调用本地方法将class字节码解析成Class对象
- findClass：找到class字节码文件并读到内存，然后调用defineClass，子类必须实现findClass
- loadClass：实现双亲委派
## 双亲委派模型
### 流程
- 类加载器接收到类加载的请求
- 将请求委派给父类加载器
- 父类加载器无法加载，子类加载器尝试加载
### 为什么要双亲委派
- 保证各个类在各个类加载器中都是同一个类
- 保证官方类库和扩展类库的加载安全性，不会被覆盖
### 破坏双亲委派
- 继承ClassLoader抽象类
- 重写findClass和loadClass方法
- java.开头的官方类只能由启动类加载器加载
# JVM调优
## 调优工具
- jconsole
- jvisualVM
## 调优参数
- -Xms：初始堆大小
- -Xmx：最大堆大小
- -Xmn：堆中新生代大小
## GC参数设置
- -XX:+Use 收集器 GC
- -XX:+UseCMSGC
- -XX:+UseG1GC